When I add a person to the desktop I now just put it into a fixed loccation. All cards appear at the same spot. This might not stand the test of time.

I can imagine all sorts of weird algorithms to pick an "appearance" point. Things could be added into some kind a a grid. Once positions are in the model I could do some weird stuff and look for nice big areas to bring things in. Do you know if there any conventions for this kind of thing?


That is a fun and classic UI layout problem â€” how to pick a â€œgoodâ€ initial position for new draggable elements in a spatial UI like your Desktop. Thereâ€™s no single convention, but there are a few time-tested strategies that you might find inspiring or useful, depending on how dynamic or tidy you want things to feel.

â¸»

ðŸ§­ Guiding Principles

Before diving into algorithms, think about:
	â€¢	User expectations: Should new cards appear near the one that spawned them?
	â€¢	Avoiding overlap: Should cards auto-avoid colliding with existing ones?
	â€¢	Spatial metaphor: Are cards â€œpinnedâ€ to a canvas (like index cards on a corkboard) or part of a dynamic layout?
	â€¢	Consistency: Should they appear in the same area every time?

â¸»

ðŸ›  Common Strategies

1. Offset from Source (Simple Heuristic)

If a new card is added from another (e.g. via context menu on Person A), place it offset from the source:

let newPosition = CGPoint(x: source.position.x + 40, y: source.position.y + 40)

âœ… Intuitive
âŒ May cause overlap if done repeatedly.

â¸»

2. Spiral or Grid Sweep (Collision Avoidance)

Start from a desired anchor point and spiral or sweep out in a grid pattern until you find an empty space.

You could do something like this:

func findAvailablePosition(near origin: CGPoint, in occupied: [CGPoint]) -> CGPoint {
    let spacing: CGFloat = 150
    let maxAttempts = 100
    for i in 0..<maxAttempts {
        let dx = CGFloat((i % 5) - 2) * spacing
        let dy = CGFloat((i / 5) - 2) * spacing
        let point = CGPoint(x: origin.x + dx, y: origin.y + dy)
        if !occupied.contains(where: { distance($0, point) < spacing }) {
            return point
        }
    }
    return origin // fallback
}

âœ… Prevents overlap
âœ… Feels natural if tuned
âŒ Adds some logic overhead

â¸»

3. Snap to Grid

Divide the canvas into a regular grid and assign the next open slot.

let gridSize: CGFloat = 200
let col = Int(lastCard.position.x / gridSize)
let row = Int(lastCard.position.y / gridSize) + 1
let newPos = CGPoint(x: CGFloat(col) * gridSize, y: CGFloat(row) * gridSize)

âœ… Visually tidy
âŒ Can feel rigid unless you allow dragging afterward

â¸»

4. Radial Expansion

From a central point (say the first card), arrange others in a growing circle or radial tree â€” useful for genealogical layouts.

âœ… Visually appealing for small sets
âŒ Can get messy for many cards

â¸»

5. Force-Directed Relaxation (Advanced)

Model cards as repelling particles and let them â€œsettleâ€ into open positions.

âœ… Elegant layouts
âŒ Complex to implement
âŒ Can feel jittery or confusing to users

â¸»

ðŸ§ª Suggested Starter: Grid-Like Heuristic with Offset

Hereâ€™s a basic hybrid you might try first:

func nextCardPosition(around anchor: CGPoint, existing: [CGPoint]) -> CGPoint {
    let spacing: CGFloat = 160
    let directions: [CGPoint] = [
        .init(x: 0, y: -1), .init(x: 1, y: 0),
        .init(x: 0, y: 1), .init(x: -1, y: 0),
        .init(x: 1, y: -1), .init(x: -1, y: -1),
        .init(x: 1, y: 1), .init(x: -1, y: 1)
    ]
    for dir in directions {
        let candidate = CGPoint(x: anchor.x + dir.x * spacing, y: anchor.y + dir.y * spacing)
        if !existing.contains(where: { distance($0, candidate) < spacing * 0.9 }) {
            return candidate
        }
    }
    return CGPoint(x: anchor.x + spacing, y: anchor.y + spacing) // fallback
}

This gives a â€œbloomâ€ effect, expanding outward from the anchor in a 3x3 grid.

â¸»

ðŸ“¦ Bonus: Track â€œlastDropPositionâ€

If the DesktopModel tracks the last place a card was added, you can evolve simple heuristics like:

model.lastDropPosition = nextCardPosition(around: model.lastDropPosition, existing: model.cardPositions())

Let me know how whimsical, tidy, or â€œnaturalâ€ you want the layout to feel, and I can help refine the strategy or generate code accordingly!
