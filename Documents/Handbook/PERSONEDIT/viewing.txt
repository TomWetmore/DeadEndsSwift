----------------------------- ME -----------------------------------
I'm trying to find a way to "chart the essentials" in order to understand the architecture of all the Views and their @-properties. Here is the chart so far. Please comment.
---------------------------
RootView
...
case .gedcomTreeEditor(let person):
    GedcomTreeEditor( viewModel: GedcomTreeModel(), root: person.root)
       .navigationTitle("Gedcom Tree Editor")
...
--------------------------------
GedcomTreeEditor
--------------------------------
struct GedcomTreeEditor: View
    @ObservedObject var viewModel: GedcomTreeModel
    var root: GedcomNode // Root of editable tree.
    var body: some View
        VStack
            ScrollView
                LazyVStack(alignment: .leading, spacing: 0)
                    NodeRow(node: root, viewModel: viewModel)
            GedcomTreeEditorButtons(viewModel: viewModel)
--------------------------------
GedcomTreeEditorButtons
--------------------------------
struct GedcomTreeEditorButtons: View
    @ObservedObject var viewModel: GedcomTreeModel
    var undoManager: UndoManager?
    var body: some View
        HStack
            Button("Parent")
            Button("First Child")
            Button("Next Sib")
            Button("Prev Sib")
                Divider()

----------------- CHAT GPT-------------------------------------------------------
Your chart captures much of the component hierarchy, @-property responsibilities, and data flow in your SwiftUI architecture.  Let me walk through:

ğŸ§­ Overall Observations
âœ… Whatâ€™s Working Well
â€¢ Clear separation of concerns between:
â€¢ GedcomTreeEditor (View-level layout)
â€¢ GedcomTreeModel (state and logic)
â€¢ GedcomTreeUndoManager (history management)
â€¢ Good object ownership model: GedcomTreeModel holds state, GedcomNode is the data, views observe it.
â€¢ Your ViewModel chart shows well-thought command verbs like addChild, moveDown, selectNextSibling, etc.
â€¢ Use of @ObservedObject and @Published looks clean and deliberate.

ğŸ“Š Architectural Suggestions

1. Fixing Undo Hook-Up
Youâ€™re managing GedcomTreeUndoManager privately inside the view model:
    @StateObject private var undoManager = GedcomTreeUndoManager()
But your button view expects:
    var undoManager: UndoManager?
These are not the same:
â€¢ UndoManager is Appleâ€™s Cocoa-style mechanism (.undo() / .redo())
â€¢ Your GedcomTreeUndoManager is your own custom logic

ğŸ›  Suggestions:
â€¢ âœ… Either rename yours to avoid confusion (GedcomUndoStack? CustomUndoManager?)
â€¢ âœ… Or wrap your manager to make it look like an UndoManager to the button bar
â€¢ âœ… Or just pass it through cleanly:

    GedcomTreeEditorButtons(viewModel: viewModel, undoManager: viewModel.undoManager)
And expose:
    var undoManager: GedcomTreeUndoManager { undoManager }

2. Pass Down EnvironmentObject?
Rather than @ObservedObject var viewModel: GedcomTreeModel everywhere, consider injecting @EnvironmentObject into all subviews after the root GedcomTreeEditor.  This reduces argument repetition:
    GedcomTreeEditorButtons().environmentObject(viewModel)
    NodeRow(node: kid)

And in those views:
    @EnvironmentObject var viewModel: GedcomTreeModel
You can mix both â€” keep explicit for the top-level, and use @EnvironmentObject for leaf views.

3. Consider a Single Source of Truth for Selection
If youâ€™re treating selectedNode as a cursor throughout the tree, make sure:
â€¢ Changes always go through viewModel.select(...)
â€¢ Clicking or editing in a row promotes that row to selectedNode
Youâ€™ve already started doing this â€” thatâ€™s perfect.

4. Document @-Properties
Youâ€™re asking about â€œannotatingâ€ SwiftUI codebases. For @-property annotations, I recommend:

ğŸ“– Inline Comments Above Each:
    /// The node currently selected by the user for editing.
    @Published var selectedNode: GedcomNode?

    /// Tracks expansion state of each node in the view by UUID.
    @Published var expanded: Set<UUID>
Or use SwiftDocC (///) for tools like Xcodeâ€™s documentation viewer.

ğŸ§¾ Suggested Enhancements to Your Chart

Hereâ€™s a lightly enhanced version of your structure:

RootView

NavigationStack {
    case .gedcomTreeEditor(let person):
        GedcomTreeEditor(viewModel: GedcomTreeModel(), root: person.root)
}

GedcomTreeEditor: View
â€¢ Props:
â€¢ @ObservedObject var viewModel (or .environmentObject)
â€¢ var root: GedcomNode
â€¢ Layout:
â€¢ ScrollView with LazyVStack of NodeRows
â€¢ GedcomTreeEditorButtons

NodeRow: View
â€¢ Props:
â€¢ @ObservedObject var node
â€¢ @ObservedObject var viewModel
â€¢ UI:
â€¢ Chevron if expandable
â€¢ Level, Key, Tag, Value
â€¢ Recursive children if expanded

GedcomTreeEditorButtons: View
â€¢ Props:
â€¢ @ObservedObject var viewModel
â€¢ var undoManager: GedcomTreeUndoManager?
â€¢ Button Groups:
â€¢ Selection/navigation
â€¢ Structural editing (add/delete/move)
â€¢ Undo/redo

GedcomTreeModel: ObservableObject
â€¢ @Published:
â€¢ expanded, selectedNode
â€¢ Private State:
â€¢ undoManager: GedcomTreeUndoManager
â€¢ Commands:
â€¢ addChild(to:), moveDown(_), selectParent()â€¦

GedcomTreeUndoManager
â€¢ Stacks: undoStack, redoStack
â€¢ Deltas:
â€¢ .add, .remove, .move, .editTag, .editValue
â€¢ Methods:
â€¢ register(_ delta)
â€¢ undo(), redo()
â€¢ apply(delta), applyInverse(delta)

âœï¸ Developer Documentation Tips
Here are common tricks developers use to understand SwiftUI view architecture:
ğŸ“„ 1. Static ASCII View Diagrams
Just like youâ€™ve done. This is immensely helpful. Some teams annotate these with colors or icons for state/data direction.

ğŸ§± 2. SwiftUI Previews with Comments
You can write:

#Preview {
    GedcomTreeEditor(viewModel: previewViewModel, root: previewRoot)
        // View: Tree Editor
        // Props: Editable root, view model
}

ğŸ” 3. Live View Tree
Use Xcodeâ€™s View Debugger to visually inspect the hierarchy at runtime:
â€¢ Run your app
â€¢ Choose â€œDebug View Hierarchyâ€
â€¢ Youâ€™ll see exactly what view owns what

ğŸ“’ 4. Codebook
Maintain a DEVELOPERS.md or ARCHITECTURE.md file at the root of your repo, containing:
â€¢ View hierarchy diagrams
â€¢ Rules for state ownership
â€¢ Notes about where @StateObject vs. @EnvironmentObject is used

âœ… Summary
Youâ€™re building a well-architected SwiftUI app, with:
â€¢ Strong MVVM patterns
â€¢ Good data bindings
â€¢ Clean command handling
â€¢ Excellent use of Swift structures (UndoManager, custom enums, extensions)

Youâ€™re already at a point where many seasoned SwiftUI devs plateau â€” keep refining and documenting what youâ€™ve got and your understanding will snowball.

Here is a structured, human-readable Architecture Sheet for your GedcomTreeEditor feature in DeadEndsSwift, designed to help you grasp the relationships between Views, Models, and Data Bindings at a glance.

ğŸ§­ Gedcom Tree Editor â€“ Architecture Sheet

ğŸ“ Top-Level View Hierarchy

RootView
â””â”€â”€ GedcomTreeEditor (for a selected person)
    â”œâ”€â”€ ScrollView
    â”‚   â””â”€â”€ LazyVStack
    â”‚       â””â”€â”€ NodeRow (recursive)
    â”‚           â””â”€â”€ NodeRow (for each child)
    â””â”€â”€ GedcomTreeEditorButtons

ğŸ“¦ View Components and Data Bindings

ğŸ§± GedcomTreeEditor: View

Property
Type
Purpose
@ObservedObject viewModel
GedcomTreeModel
Central view model for tree manipulation
root
GedcomNode
Root node of the editable GEDCOM record

ğŸ“Œ Subviews:
â€¢ Displays one full record as a collapsible tree of editable NodeRows
â€¢ Button bar for navigation, structural changes, and undo/redo

ğŸ§± NodeRow: View (Recursive)

Property
Type
Purpose
@ObservedObject node
GedcomNode
The GEDCOM node this row represents
@ObservedObject viewModel
GedcomTreeModel
For expansion state, selection, actions

ğŸ“Œ Key Behaviors:
â€¢ Indents by level (node.lev)
â€¢ Expand/collapse chevron if node has children
â€¢ Editable text fields for tag and value
â€¢ Recursively renders children when expanded

ğŸ§± GedcomTreeEditorButtons: View

Property: Type: Purpose
@ObservedObject viewModel: GedcomTreeModel: For button actions and state
undoManager: GedcomTreeUndoManager?: Custom undo/redo logic

ğŸ“Œ Button Groups:

Group: Buttons
Navigation: Parent / First Child / Next / Prev
Structure: Add Child / Add Sibling / Delete
History: Undo / Redo

ğŸ”§ Consider grouping buttons visually with spacing or dividers

ğŸ›ï¸ ViewModel and State Objects

ğŸ§  GedcomTreeModel: ObservableObject

Property: Type: Purpose
@Published expanded: Set<UUID>: Tracks which nodes are expanded
@Published selectedNode: GedcomNode?: Currently selected node for editing
@StateObject undoManager: GedcomTreeUndoManager: Custom undo stack for tree changes

ğŸ“Œ Commands (API surface):

toggleExpansion(for:)
addChild(to:)
addSibling(to:)
remove(_:)
moveUp(_:) / moveDown(_:)
selectParent()
selectFirstChild()
selectNextSibling()
selectPrevSibling()

ğŸ” GedcomTreeUndoManager: ObservableObject

Property: Type: Purpose
undoStack: [EditDelta]: Stack of reversible tree edits
redoStack: [EditDelta]: Stack of undone edits
canUndo: Bool: Computed from undoStack
canRedo: Bool: Computed from redoStack

ğŸ“Œ Key Methods:

register(_:)
undo()
redo()

ğŸ“Œ EditDelta Enum Cases:
â€¢ add(parent, newNode)
â€¢ remove(parent, removedNode, previousSibling)
â€¢ move(node, oldParent, newParent, oldPrevSib, newPrevSib)
â€¢ editTag(node, oldTag, newTag)
â€¢ editValue(node, oldVal, newVal)

ğŸ“ Data Types

ğŸ§± GedcomNode: ObservableObject

Property: Type: Purpose
id: UUID: Uniquely identifies each node
tag: String: GEDCOM tag (e.g., NAME, BIRT)
val: String?: GEDCOM value
kid: GedcomNode?: First child in sibling chain
sib: GedcomNode?: Next sibling

ğŸ“Œ Extensions Used
    insertChild(_:afterSibling:)
    removeChild(_:)
    move(toParent:afterSibling:)

ğŸ§­ Data Flow Summary (mermaid)
graph TD
  RootView --> GedcomTreeEditor
  GedcomTreeEditor -->|recursively renders| NodeRow
  GedcomTreeEditor --> GedcomTreeEditorButtons

  GedcomTreeEditor -->|injects| GedcomTreeModel
  NodeRow -->|reads/writes| GedcomTreeModel
  GedcomTreeEditorButtons -->|uses| GedcomTreeModel
  GedcomTreeModel -->|owns| GedcomTreeUndoManager
  GedcomTreeUndoManager -->|registers/applys| EditDelta

ğŸ“‹ Recommendations
â€¢ âœ… Rename undoManager to avoid confusion with UIKitâ€™s UndoManager
â€¢ âœ… Convert subviews to use @EnvironmentObject for GedcomTreeModel
â€¢ âœ… Document @Published properties with /// comments
â€¢ âœ… Maintain this architecture sheet in your repo (ARCHITECTURE.md)
â€¢ âœ… Consider visual grouping of buttons (e.g., HStack + Divider or Spacer)
