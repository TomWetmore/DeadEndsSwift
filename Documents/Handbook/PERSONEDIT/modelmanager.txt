ME
1. GedcomTreeEditor.
The GedcomTreeEditor is simple. It is stack of GedcomTreeEditorRows. It has to observe the ViewModel because it needs to know the expanded set and the selected node.

2. GedcomTreeModel.
The GedcomTreeModel is an ObservableObject that publishes the expanded set and the selected node. However, it also has the link to the Tree Manager, which is a "smell" in current changing architecture.

3. GedcomTreeManager.
The GedcomGTreeManager is the "edit manager" for the Gedcom tree. It has three main external interfaces:
   	a. edit (poor name) -- called from user edit actions with an EditDelta. The delta is run and then put on the undo stack; redo stack cleared.
   	b. undo -- undoes the last delta and puts it on the redo stack.
   	c. redos -- redoes the last undone delta and puts it on the undo stack.
The Manager represents a rather large architectural shift that is not yet cleaned up. That shift is the fact that all changes to the Gedcom tree now pass first to the manager in the form of EditDeltas; they used to go to the ViewModel. The Manager is now supposed to use the ViewModel to make the changes, while the ViewModel will be making direct calls on GedcomNodes to effect those changes.

4. GedcomTreeEditorRow.
The GedcomTreeEditorRow is the view for a single line in the editor. It consists of an HStack of fields. Two of those fields are editable, so the GedcomTreeEditorRow requires access to the TreeManager to make those changes.

5. TreeEditorButtons.
The TreeEditorButtons is a view holding a number of buttons the user can hit. Some buttons change the selected node. Two of them activate the undo and redo mechanism. And the others change the three.

    a. The undo and redo buttons can go directly to the TreeManager.
    b. Change of selection can go direct to the ViewModel
    b. The buttons that change the tree now have to go to the TreeManager which will go to the ViewModel which will go to the GedcomNodes.

Right now the ViewModel has a reference to the TreeManager. This seems a bit smelly to me.

Do you have any advice on how to plumb these objects, particularly the Model and Manager?

CHATGPT

You‚Äôre articulating a classic MVU-style (Model‚ÄìView‚ÄìUpdate) architecture in SwiftUI, but you‚Äôre running into a common architectural friction point: how to cleanly separate responsibilities between:
‚Ä¢ The ViewModel (GedcomTreeModel)
‚Ä¢ The Command Processor / Editor (GedcomTreeManager)
‚Ä¢ The Mutable Model Layer (GedcomNode trees)

You‚Äôve also recognized the ‚Äúsmell‚Äù of the ViewModel having a reference to the TreeManager, especially now that changes are supposed to flow the other way.

Let‚Äôs walk through it carefully and then propose a cleaner architecture.

Recommendation
‚Ä¢ The GedcomTreeModel should NOT hold a reference to the GedcomTreeManager.
‚Ä¢ Instead, the GedcomTreeManager should own the model (GedcomTreeModel), and make changes to it via well-defined APIs.
‚Ä¢ The Views observe the GedcomTreeModel.
‚Ä¢ The Views send user actions to the GedcomTreeManager, not the GedcomTreeModel.

This results in a unidirectional flow:

User Action
   ‚¨á
GedcomTreeManager
   ‚¨á
GedcomTreeModel (state + selection)
   ‚¨á
SwiftUI Views

Conceptual Roles

Component             : Role
GedcomTreeEditorRow   : View for one GEDCOM line. Binds to state in GedcomTreeModel. Calls GedcomTreeManager for edits.
GedcomTreeEditor      : View of all rows. Observes GedcomTreeModel for expanded state, selection.
GedcomTreeModel       : Holds published UI state: expanded, selectedNode. No business logic.
GedcomTreeManager     : State machine for editing. Accepts deltas, manages undo/redo, updates GedcomTreeModel.

Problem with Current Setup
You‚Äôre seeing this kind of diagram (current state):

GedcomTreeModel
  ‚îú‚îÄ Published: expanded, selectedNode
  ‚îî‚îÄ Holds reference to ‚Üí GedcomTreeManager
                         ‚îî‚îÄ Applies changes back to ‚Üí GedcomTreeModel

This creates two-way dependency, which is indeed a smell.

Preferred Setup (Reversed Ownership)
GedcomTreeManager
  ‚îú‚îÄ Holds reference to GedcomTreeModel
  ‚îú‚îÄ Applies deltas to GedcomTreeModel and GedcomNode tree
  ‚îú‚îÄ Manages undo/redo
  ‚îî‚îÄ Is the central update authority

GedcomTreeModel
  ‚îú‚îÄ @Published: expanded, selectedNode
  ‚îî‚îÄ Is a dumb observable model ‚Äî no business logic

In SwiftUI terms:
‚Ä¢ Views bind to @ObservedObject var viewModel: GedcomTreeModel
‚Ä¢ Views pass user edits to GedcomTreeManager (e.g. via closures, or directly)

Plumbing Advice
‚úî GedcomTreeManager should be created early and injected
‚Ä¢ It should own the GedcomTreeModel (or receive it on init)
‚Ä¢ Then you inject both the manager and the model into your view hierarchy

let model = GedcomTreeModel()
let manager = GedcomTreeManager(model: model)
let editor = GedcomTreeEditor(viewModel: model, manager: manager)

This avoids cyclic references.

‚úî Let Views talk to both:
Your view hierarchy can look like this:

struct GedcomTreeEditor: View {
    @ObservedObject var viewModel: GedcomTreeModel
    let manager: GedcomTreeManager
    var body: some View {
        VStack {
            ForEach(model.rootNodes) { node in
                GedcomTreeEditorRow(node: node, model: viewModel, manager: manager)
            }
            TreeEditorButtons(model: viewModel, manager: manager)
        }
    }
}

This makes data flow clear:
‚Ä¢ Views read from the viewModel
‚Ä¢ Views send edits to the manager

What happens when the manager needs to mutate selection or expanded set?
Let the manager mutate the model directly (it‚Äôs the sole authority), using well-named methods:

class GedcomTreeModel: ObservableObject {
    @Published var selectedNode: GedcomNode?
    @Published var expanded: Set<UUID> = []

    func toggleExpansion(for node: GedcomNode) {
        if expanded.contains(node.id) {
            expanded.remove(node.id)
        } else {
            expanded.insert(node.id)
        }
    }

    func setSelected(_ node: GedcomNode?) {
        selectedNode = node
    }
}

Then from GedcomTreeManager:

model.setSelected(kid)
model.toggleExpansion(for: dad)

Extra Cleanups
‚Ä¢ The GedcomTreeModel can be reset/reloaded/replaced by the manager if needed (model = GedcomTreeModel(fromTree: ...)).
‚Ä¢ The undo stack should store deltas only, not full trees or view models.
‚Ä¢ Consider eventually splitting the GedcomTreeModel into:
‚Ä¢ A view-state model (expanded, selectedNode)
‚Ä¢ A record-index model (for the actual data)
But this is a future refinement.

Final Summary
Principle: Guideline
üîÑ Avoid cyclic dependencies: Let GedcomTreeManager own the model, not vice versa
üëÅ Views observe model: Use @ObservedObject var model: GedcomTreeModel
üéØ Views delegate actions: Use manager.edit(...), manager.undo() etc.
üß† Manager is central authority: It mutates the model, not the other way around
