
Decision to NOT USE OutlineGroup.

Why padding(.leading) Has No Effect Here
In this code:

OutlineGroup(node, children: \.kids) { n in
    Text("\(n.depth) \(n.tag) \(n.val ?? "")")
        .padding(.leading, CGFloat(n.depth) * 16)
}

SwiftUI renders an internal tree structure using built-in indentation, and tries to layout and align everything as if it were a table ‚Äî often using spacing and alignment guides that don‚Äôt respond well to your manual padding.

So:
‚Ä¢ The indentation you see isn‚Äôt your doing.
‚Ä¢ .padding(.leading) is being overridden or neutralized by OutlineGroup.

Two Options for Fixing Layout

Option 1: Use Label View Consistently Inside OutlineGroup
This ensures that SwiftUI doesn‚Äôt break alignment due to uneven content.  Try:

OutlineGroup(node, children: \.kids) { n in
    HStack {
        Text("\(n.tag)")
        if let val = n.val {
            Text(val).foregroundColor(.secondary)
        }
    }
    .font(.system(.body, design: .monospaced))
}
This preserves SwiftUI‚Äôs internal indentation system but gives you better visual consistency.

Option 2 (Better): Build Your Own Outline (No OutlineGroup)
If you want full layout control, drop OutlineGroup and write a recursive view.
This is a bit more work, but gives you precise layout and stable expansion state (eventually). Here‚Äôs a starting point:

struct GedcomTreeView: View {
    var node: GedcomNode
    var body: some View {
        ScrollView {
            VStack(alignment: .leading, spacing: 4) {
                treeRow(for: node)
            }
            .padding()
        }
    }
    @ViewBuilder
    func treeRow(for node: GedcomNode) -> some View {
        Text("\(node.depth) \(node.tag) \(node.val ?? "")")
            .font(.system(.body, design: .monospaced))
            .padding(.leading, CGFloat(node.depth) * 16)

        // Recurse manually over kids
        var child = node.kid
        while let c = child {
            treeRow(for: c)
            child = c.sib
        }
    }
}

This version respects .padding fully, uses your real kid/sib model, and is the foundation for a custom expandable tree later.

Summary

Approach: Control: Looks Aligned: Expandable: Uses OutlineGroup
OutlineGroup: ‚ùå Low: ‚ùå Unpredictable: ‚úÖ Built-in: ‚úÖ Yes
Custom recursive view: ‚úÖ Full: ‚úÖ Your way: ‚úÖ (manual): ‚ùå No

So for visual precision, switch to a recursive view. You‚Äôve already done the hard part (depth tracking and tree structure), so the rewrite is minimal.

Would you like help converting your tree viewer fully into a recursive SwiftUI view that can support expansion toggles later on?

ME
When you say custom expandable tree later does this mean I will be able to collapse different parts of the tree. And when we reach the point where I start editing the tree directly will this approach support that?

Yes ‚Äî and you‚Äôre already 80% of the way there with your current model.
Let‚Äôs break this down into the two questions you just asked:

1. Will a custom recursive tree view let me collapse/expand arbitrary parts of the tree?
Yes ‚Äî absolutely.
In fact, this is the only way to get per-node expand/collapse behavior that:
‚Ä¢ Persists across view redraws
‚Ä¢ Can be customized (e.g. auto-expand certain tags, remember user toggles)
‚Ä¢ Isn‚Äôt limited by OutlineGroup‚Äôs opaque state
You‚Äôll need:
‚Ä¢ A Set<ObjectIdentifier> or [ObjectIdentifier: Bool] in your view model (or local state)
‚Ä¢ A small disclosure toggle (‚ñ∂Ô∏é / ‚ñº) per node
‚Ä¢ A recursive view that only renders children if their parent is expanded
You already have the tree structure and the depth value, so the rest is just rendering logic.

2. Will this approach support editing the tree directly later?
Yes ‚Äî and better than OutlineGroup ever could.
Once you have your own recursive view:
‚Ä¢ You can add buttons or context menus for:
‚Ä¢ Insert node below
‚Ä¢ Add child
‚Ä¢ Change tag or value
‚Ä¢ Delete node
‚Ä¢ You can use @Binding or two-way delegation to let the user click and edit a line
‚Ä¢ You can even embed an inline editable TextField instead of static text

This means:

Feature: Supported by OutlineGroup: Supported by custom view
Click to edit value/tag: ‚ùå (difficult): ‚úÖ (easy)
Show inline controls (add/delete): ‚ùå: ‚úÖ
Fine-grained expand/collapse: ‚ùå (all or nothing): ‚úÖ
Highlight syntax: ‚ùå: ‚úÖ
Switch formats dynamically:: ‚ùå: ‚úÖ

What‚Äôs the underlying power?
Your recursive GedcomNode tree is already expressive enough to support:
‚Ä¢ Live editing
‚Ä¢ UI events per node
‚Ä¢ Traversal by tag or content
‚Ä¢ Read-only or read-write views
‚Ä¢ Per-node metadata (highlighted, invalid, expanded, etc.)

Your treeRow(for:) function becomes the single place to orchestrate rendering + controls per node.

What You‚Äôll Gain:
‚Ä¢Control of layout (indentation, spacing, alignment)
‚Ä¢Visual consistency
‚Ä¢Expand/collapse on a per-node basis
‚Ä¢Live editing: click to change tag/value
‚Ä¢Contextual actions: insert child, delete, reorder
‚Ä¢Syntax or error highlighting (e.g. missing DATE or PLAC)
‚Ä¢Switch between formats (GEDCOM / JSON / YAML / tree)

Conclusion:
Yes, a custom tree view:
‚Ä¢‚úîÔ∏è Enables full expand/collapse per node
‚Ä¢‚úîÔ∏è Sets you up perfectly for direct editing
‚Ä¢‚úîÔ∏è Is more consistent with the rest of your DeadEnds philosophy: you own the logic and the structure

Would you like me to sketch a prototype of this custom tree view with expansion toggles and a simple way to start editing nodes? It can be done in under 50 lines as a base layer.

Yes, please sketch the prototype.

Absolutely ‚Äî here is a clean, compact SwiftUI prototype for a custom expandable GEDCOM tree view, ready to drop into your GedcomTreeView.swift.

It supports:
	‚Ä¢	Displaying the GedcomNode tree
	‚Ä¢	Expand/collapse per node
	‚Ä¢	Indented layout
	‚Ä¢	Toggles using ‚ñ∂Ô∏é / ‚ñº for disclosure
	‚Ä¢	Designed to evolve into a full editor later

‚∏ª

‚úÖ Prototype: ExpandableGedcomTreeView

import SwiftUI
import DeadEndsLib

struct GedcomTreeView: View {
    let root: GedcomNode

    /// Tracks which nodes are expanded.
    @State private var expandedNodes: Set<ObjectIdentifier> = []

    var body: some View {
        ScrollView {
            VStack(alignment: .leading, spacing: 2) {
                treeRow(for: root)
            }
            .padding()
        }
    }

    @ViewBuilder
    private func treeRow(for node: GedcomNode) -> some View {
        let isExpandable = node.kid != nil
        let isExpanded = expandedNodes.contains(ObjectIdentifier(node))

        HStack(spacing: 4) {
            // Disclosure indicator
            if isExpandable {
                Button(action: {
                    toggle(node)
                }) {
                    Image(systemName: isExpanded ? "chevron.down" : "chevron.right")
                        .font(.system(size: 12, weight: .semibold))
                        .foregroundColor(.gray)
                }
                .buttonStyle(.plain)
                .frame(width: 16)
            } else {
                Spacer().frame(width: 16) // align with buttons
            }

            // Node label
            Text("\(node.tag) \(node.val ?? "")")
                .font(.system(.body, design: .monospaced))
        }
        .padding(.leading, CGFloat(node.depth) * 16)

        // Recursively render children if expanded
        if isExpanded {
            var child = node.kid
            while let current = child {
                treeRow(for: current)
                child = current.sib
            }
        }
    }

    /// Toggle expanded/collapsed state for a node
    private func toggle(_ node: GedcomNode) {
        let id = ObjectIdentifier(node)
        if expandedNodes.contains(id) {
            expandedNodes.remove(id)
        } else {
            expandedNodes.insert(id)
        }
    }
}

üß™ To Use It

In your PersonEditorView, just replace your call to GedcomTreeView with:

GedcomTreeView(root: vm.rootNode)

üß† What You Can Add Next

From here, you can easily grow it:
	‚Ä¢	üîß Replace the Text with editable TextField for tag or value
	‚Ä¢	‚ûï Add buttons for insert child / sibling / delete
	‚Ä¢	üß± Add a view model for managing tree editing operations
	‚Ä¢	üñçÔ∏è Apply colors or highlights based on GEDCOM tag types
	‚Ä¢	üîÅ Hook into undo/redo tracking

‚∏ª

üìè Summary of Key Elements

Feature
How it works
Expand/collapse
Stored in Set<ObjectIdentifier>
Recursion
Manual with kid/sib traversal
Indentation
Based on node.depth √ó 16 points
Disclosure triangle
SF Symbols: "chevron.right", "down"
Future editing
Easy to add: just replace Text(...)


Let me know if you‚Äôd like to evolve this into a full editable tree, or to support tree diffing for change tracking. You now have the foundation.
