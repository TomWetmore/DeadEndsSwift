What is a Binding in SwiftUI?

A Binding is a two-way connection between a piece of state (like a variable in your view model) and a view (like a TextField, Picker, or Toggle).

It allows:
‚Ä¢ The view to display the current value
‚Ä¢ The user to change that value
‚Ä¢ And the change automatically updates your model

Example: One-Way vs Two-Way

Let‚Äôs say you have this: @State var name = "Thomas"
If you write: Text(name)
That‚Äôs one-way: you show the name, but can‚Äôt change it.

If you write: TextField("Name", text: $name)
The $name here is a Binding ‚Äî it links the text field to the name variable. When the user types into the field, the name variable is automatically updated.

The $ Prefix
‚Ä¢ When you write $name, you are saying: ‚ÄúGive me a Binding to name.‚Äù
‚Ä¢ It‚Äôs shorthand for:
    Binding(get: { name }, set: { name = $0 })

Where Bindings Come From
There are two common places you get a binding:

1. From @State:
    @State var value: Int = 5
    Slider(value: $value)

2. From @ObservedObject or @StateObject
    @ObservedObject var vm: ViewModel
    TextField("Name", text: $vm.name)

If vm.name is a @Published var name: String, this works.

Why Create a Binding Manually?
Sometimes you have:
‚Ä¢ A non-optional field in a Picker
‚Ä¢ But the model uses an optional, like SexType?
In that case, you make a Binding manually to adapt between them:

var sexBinding: Binding<SexType> {
    Binding(
        get: { vm.sex ?? .unknown },   // use .unknown if nil
        set: { vm.sex = $0 }           // update the optional with new value
    )
}

Now you can use sexBinding in a Picker that expects SexType, not SexType?.
Concept:What it means
Binding<T>:A read/write connection between view and data
$value:Shorthand for a binding to value
@State:Owns local view state
@ObservedObject:Links view to a view model (@Published properties)
Binding(...):Manually create a bridge between two values



So let‚Äôs step through Binding, not as a Swift incantation, but as if we were systems-level engineers reverse-engineering the feature from first principles.

‚∏ª

Think of Binding<T> as a Lightweight Reference

In old-school C: char* name = "Tom";

You can pass that pointer around, read it, modify it, and anyone with the pointer sees the change.

Swift usually avoids pointers, but Binding<T> is the SwiftUI way of saying:
‚ÄúThis thing refers to a value that is stored somewhere else, and I want to read and write it through this object.‚Äù

It‚Äôs like:

struct Binding<Value> {
    let get: () -> Value
    let set: (Value) -> Void
}

That‚Äôs it.
If you squint, this is a pair of function pointers: one for getting, one for setting. A very C-like idea.

Where the Data Lives

In SwiftUI:
‚Ä¢	@State var name = "Tom"
‚Üí The data lives in the View struct‚Äôs internal storage
‚Üí $name gives you a Binding<String> (reference to that storage)
‚Ä¢	@ObservedObject var vm: ViewModel with @Published var name
‚Üí The data lives in an external class, probably on the heap
‚Üí $vm.name gives you a Binding<String>, pointing to vm.name
‚Ä¢	When you manually create a Binding, like this:

Binding(get: { self.sex ?? .unknown }, set: { self.sex = $0 })

You‚Äôre saying:
‚ÄúLet me expose this property as a pointer-like object, but I‚Äôll control what read and write mean.‚Äù


What SwiftUI Views Expect

Controls like TextField, Toggle, and Picker don‚Äôt want ownership of the data ‚Äî they just want a reference to it.

So SwiftUI defines their initializer to take a Binding<T>, e.g.:

TextField("Name", text: Binding<String>)

This gives the TextField a reference to the variable ‚Äî not a copy.

So when the user types:
‚Ä¢	SwiftUI calls set("New Value") on the binding
‚Ä¢	That goes and updates the underlying storage

What‚Äôs with the $ Syntax?
This is syntactic sugar for:

@State var name = "Tom"

$name  // ‚üπ Binding<String>(get: { name }, set: { name = $0 })


You can define it yourself like this:

var _name = State(initialValue: "Tom")
var name: String {
    get { _name.wrappedValue }
    set { _name.wrappedValue = newValue }
}
var $name: Binding<String> {
    _name.projectedValue  // literally the Binding
}

So $name is not magic ‚Äî it‚Äôs just SwiftUI exposing the getter/setter object behind @State.


Want to See the Binding Mechanism with Your Own Code?

Try this minimal SwiftUI view:struct BindingDemo: View {
    @State private var name: String = "Tom"

    var body: some View {
        VStack {
            TextField("Enter name", text: $name)
            Text("You typed: \(name)")
        }
        .padding()
    }
}

This works because:
	‚Ä¢	@State creates storage
	‚Ä¢	$name gives a pointer to that storage
	‚Ä¢	TextField modifies it
	‚Ä¢	Text reads from it

If You Were Writing This in C
Think of:

void drawTextField(char* label, char** stringPointer) {
    // read *stringPointer to get value
    // let user modify *stringPointer
}

Binding<T> is the Swift equivalent of char**, but wrapped in a safe, composable struct.

Why SwiftUI Had to Do This

SwiftUI is declarative ‚Äî the UI is a function of the state. But when you interact with UI, you don‚Äôt just want a copy of state ‚Äî you want to modify the real data from inside a view builder.

They needed a way to pass references safely, with full control over how reads and writes behave. Hence: Binding<T>.

And if that‚Äôs all they‚Äôd said up front, many experienced programmers (like yourself) would have nodded and said: ‚ÄúAh. Not magic. Just a safe reference abstraction.‚Äù


Summary

Concept
What It Really Is
@State
Storage for a value, internal to the view
$name
A Binding<String> ‚Äî a pointer to that storage
Binding<T>
A pair of closures: get and set
SwiftUI control (TextField, etc)
Takes a Binding, so it can read and write the value directly
$ prefix
Syntactic sugar for .projectedValue ‚Äî the Binding

-------------------MORE FROM A DIFFERENT QUESTION----------

I need to ask one more question about SwiftUI esoterica to complete my understanding of the model hookups. Note this code:

GedcomTreeView(root: vm.person, expandedNodes: $vm.expanded)
                    .frame(minWidth: 200, idealWidth: 300, maxWidth: .infinity, alignment: .leading)
                    .padding()

both vm and $vm are used to reference the model. Can you explain the difference?

Ahh, you‚Äôve hit on a subtle but super-important distinction: property vs. binding. Let‚Äôs break it down carefully.
1. vm
‚Ä¢ When you write vm, you‚Äôre using the object reference itself.
‚Ä¢ vm is a PersonEditorViewModel instance (an ObservableObject).
‚Ä¢ This is what you use if you want to read or call methods directly:

vm.rebuildGedcomTree()
print(vm.name)

2. $vm
‚Ä¢ The $ prefix gives you the projected value of a property wrapper.
‚Ä¢ For @StateObject var vm, the projected value is a binding to the wrapped object.
‚Ä¢ So $vm isn‚Äôt the PersonEditorViewModel itself ‚Äî it‚Äôs a Binding<PersonEditorViewModel>.

Bindings are SwiftUI‚Äôs way of creating two-way connections: a child view can change the value, and the parent‚Äôs state automatically updates.

3. Why $vm.expanded works
‚Ä¢ In your PersonEditorViewModel, you have @Published var expanded: Set<ObjectIdentifier>.
‚Ä¢ When you access $vm.expanded, SwiftUI bridges things:
‚Ä¢ vm is an ObservableObject.
‚Ä¢ $vm exposes a binding to its published properties.
‚Ä¢ That means GedcomTreeView gets a live, two-way connection to the expanded set.
‚Ä¢ If the user clicks a disclosure triangle in the tree, the child view mutates $vm.expanded, and the change flows back into the view model.

4. Visual analogy
‚Ä¢ vm ‚Üí ‚ÄúHere‚Äôs the notebook itself.‚Äù üìì
‚Ä¢ $vm ‚Üí ‚ÄúHere‚Äôs a pen clipped into that notebook that lets you write inside it.‚Äù ‚úèÔ∏è

Both give you access, but the $ version is specifically for when you want SwiftUI‚Äôs two-way plumbing to kick in.

So in your snippet:
GedcomTreeView(root: vm.person, expandedNodes: $vm.expanded)
‚Ä¢ vm.person is read-only data passed down.
‚Ä¢ $vm.expanded is a two-way binding, so the tree can update the expansion state and keep it synced with the model.

To me this sounds quite a bit like an inout parameter

Yes! You‚Äôre making the right connection ‚Äî a Binding in SwiftUI really is a lot like an inout parameter, except instead of existing just for the duration of a function call, it‚Äôs a long-lived, persistent connection between two pieces of state.

Compare directly
inout (classic Swift)
func increment(_ x: inout Int) {
    x += 1
}

var value = 10
increment(&value)   // &value passes a reference
print(value)        // 11

‚Ä¢ The & creates a temporary reference that allows increment to mutate the caller‚Äôs variable.
‚Ä¢ But once the function returns, the reference is gone.

Binding (SwiftUI)
struct CounterView: View {
    @State private var count = 0
    var body: some View {
        Stepper("Count: \(count)", value: $count)
    }
}
‚Ä¢ Here, $count is not a one-shot reference like &count.
‚Ä¢ It‚Äôs a persistent reference object (Binding<Int>) that can be passed into subviews.
‚Ä¢ That subview (Stepper) can then mutate it whenever the user clicks + or ‚Äì.
‚Ä¢ The connection stays alive as long as the view hierarchy does.

Key difference
‚Ä¢ inout ‚Üí Temporary, function-scoped reference for mutation.
‚Ä¢ Binding ‚Üí Long-lived, view-hierarchy-scoped reference that keeps parent and child state in sync automatically.
So your instinct is correct: $ feels like &, but it‚Äôs upgraded for SwiftUI‚Äôs declarative world. üöÄ

You showed me how a StateObject under the covers is a PropertyWrapper. Is Binding<Int> defined similiarly as a struct somewhere?

Binding is also a property wrapper‚Äìstyle type, but it‚Äôs a bit more bare-bones than @StateObject or @ObservedObject. It‚Äôs literally defined as a struct in SwiftUI. If you peek at the standard library headers you‚Äôll see something very close to this (I‚Äôll paraphrase the real thing to keep it readable):

/// A property wrapper type that can read and write a value
/// managed by some source of truth.
@propertyWrapper
public struct Binding<Value> {
    // These are the core storage
    private let getter: () -> Value
    private let setter: (Value) -> Void

    /// Construct a binding from closures
    public init(get: @escaping () -> Value,
                set: @escaping (Value) -> Void) {
        self.getter = get
        self.setter = set
    }

    /// Read the current value
    public var wrappedValue: Value {
        get { getter() }
        nonmutating set { setter(newValue) }
    }

    /// Access the binding itself (the projected `$` form)
    public var projectedValue: Binding<Value> { self }
}

That‚Äôs the heart of it:
‚Ä¢ A Binding<Value> is just a pair of closures: one to get the value, one to set it.
‚Ä¢ wrappedValue makes it behave like a variable: you can read or assign to it.
‚Ä¢ projectedValue returns itself, so you can use $binding to pass it deeper.

Where $ comes in

When you write @State var count = 0, SwiftUI creates a State<Int> wrapper. That wrapper has a .projectedValue of type Binding<Int>. That‚Äôs why you can write:

TextField("Enter number", text: $count)

The $count is literally the Binding<Int> created by the @State<Int> wrapper.

Just like StateObject has that hidden _vm wrapper, Binding is ‚Äújust a struct with a getter and setter.‚Äù Apple could have called it Ref<Value> and it would feel almost the same. The magic comes from how SwiftUI views consume those bindings. ‚ú®

------------------------ UNDERSTANDING THAT EARLIER CODE IN MORE DETAIL ------------
The declaration

public struct Binding<Value> {
‚Ä¢ Binding is a generic struct.
‚Ä¢ Value is the type of thing it binds to ‚Äî Int, String, Person, etc.
‚Ä¢ So Binding<Int> is ‚Äúa box that knows how to read and write an Int somewhere else.‚Äù

The stored closures

    private let getter: () -> Value
    private let setter: (Value) -> Void

‚Ä¢ Instead of storing an actual Value, it stores two functions:
    ‚Ä¢ getter takes no arguments and returns the current value.
    ‚Ä¢ setter takes a new value and stores it wherever the ‚Äúreal‚Äù value lives.
Think of this like keeping two function pointers: one for ‚Äúread‚Äù and one for ‚Äúwrite.‚Äù

The initializer

    public init(get: @escaping () -> Value,
                set: @escaping (Value) -> Void) {
        self.getter = get
        self.setter = set
    }

‚Ä¢ You create a Binding by handing it those closures.
‚Ä¢ Example:

var name = "Tom"
let b = Binding(
    get: { name },
    set: { newValue in name = newValue }
)

‚Ä¢ Now b is a binding to name. Reading/writing through b actually touches name.

The wrappedValue

    public var wrappedValue: Value {
        get { getter() }
        nonmutating set { setter(newValue) }
    }

‚Ä¢ This is the property-wrapper magic.
‚Ä¢ When you say b.wrappedValue, it calls getter().
‚Ä¢ When you assign, b.wrappedValue = 42, it calls setter(42).

Swift‚Äôs property wrapper syntax (@Binding var x) uses this wrappedValue under the hood.

The projectedValue

    public var projectedValue: Binding<Value> { self }

‚Ä¢ This is what the $ operator exposes.
‚Ä¢ So if you have @State var count = 0, then $count is the Binding<Int> that SwiftUI created.
‚Ä¢ That Binding<Int> has get/set closures pointing into SwiftUI‚Äôs state box.
‚Ä¢ You pass $count to a child view or control so it can read/write the real state.

So in practice‚Ä¶

@State private var name = "Tom"

var body: some View {
    TextField("Name", text: $name)
}

‚Ä¢ @State wraps name in a State<String> object that manages storage.
‚Ä¢ $name gives you a Binding<String> built with closures that call into that State object.
‚Ä¢ TextField only knows how to work with a Binding<String>. It doesn‚Äôt care where the data lives ‚Äî it just calls the getter when it needs the text, and calls the setter when the user types.

So really, Binding is just:
‚Ä¢ A getter function.
‚Ä¢ A setter function.
‚Ä¢ A tiny bit of syntactic sugar (wrappedValue, projectedValue) to integrate with Swift‚Äôs property wrapper system.

---------------------- EXAMPLE IN PURE SWIFT -----------------------
import Foundation

// === Our own Binding type (simplified) ===
struct Binding<Value> {
    private let getter: () -> Value
    private let setter: (Value) -> Void
    
    init(get: @escaping () -> Value,
         set: @escaping (Value) -> Void) {
        self.getter = get
        self.setter = set
    }
    
    var wrappedValue: Value {
        get { getter() }
        nonmutating set { setter(newValue) }
    }
    
    var projectedValue: Binding<Value> { self }  // enables `$`
}

// === Example use without SwiftUI ===
var age = 42

// Make a binding that points into `age`
let ageBinding = Binding<Int>(
    get: { age },
    set: { newValue in age = newValue }
)

print("Age via variable: \(age)")                 // prints 42
print("Age via binding: \(ageBinding.wrappedValue)") // prints 42

// Write through the binding
ageBinding.wrappedValue = 99
print("Age after binding write: \(age)")          // prints 99

// You can also use the `$` style (because projectedValue returns self)
let anotherRef = ageBinding.projectedValue
anotherRef.wrappedValue = 123
print("Age after another binding: \(age)")        // prints 123

Walkthrough
1. var age = 42 is our ‚Äúreal storage.‚Äù
2. ageBinding is created with closures:
    ‚Ä¢ get: { age } ‚Üí when you read, it reads age.
    ‚Ä¢set: { newValue in age = newValue } ‚Üí when you write, it assigns into age.
3.ageBinding.wrappedValue reads age (42).
4. Writing through it (ageBinding.wrappedValue = 99) mutates the real age.
5. The projectedValue ($) is just the binding itself ‚Äî so $binding and binding are the same thing here.

This is literally the same mechanism SwiftUI controls use (TextField, Toggle, etc.), except SwiftUI wires up those closures into the @State or @ObservedObject boxes.
