
The names wrappedValue and projectedValue come from a Swift language feature called Property Wrappers. SwiftUI uses them heavily (think: @State, @Published, @Binding, etc.).

What is a Property Wrapper?
A property wrapper is a Swift struct or class that defines how a property is stored, read, or written.
You use them like this:

@propertyWrapper
struct MyWrapper {
    var wrappedValue: String
}

struct Example {
    @MyWrapper var name: String  // This is the magic
}

So when you write @MyWrapper var name: String, Swift is actually generating:

var _name = MyWrapper(wrappedValue: "")
var name: String {
    get { _name.wrappedValue }
    set { _name.wrappedValue = newValue }
}

üîç wrappedValue: Always Present

Every property wrapper must implement:

var wrappedValue: Value

This is the actual value that your property appears to be.

So when you write:

@State var count: Int = 0

Swift actually creates an internal variable:

private var _count: State<Int> = State(initialValue: 0)

And then:

var count: Int {
    get { _count.wrappedValue }
    set { _count.wrappedValue = newValue }
}

‚û°Ô∏è wrappedValue gives you the underlying value.

ü™Ñ projectedValue: Optional, Used for Extra Behavior

This is where $ comes in.

If your property wrapper also defines:

var projectedValue: SomeType

Then Swift lets you write:

$myProperty  // == _myProperty.projectedValue

That‚Äôs where the $ syntax comes from. It‚Äôs not magic ‚Äî it‚Äôs sugar for .projectedValue.

üîÑ Examples from SwiftUI

@State

@State var name: String

	‚Ä¢	name accesses wrappedValue: String
	‚Ä¢	$name accesses projectedValue: Binding<String>

@Published

@Published var name: String

	‚Ä¢	name is the value
	‚Ä¢	$name is a Publisher<String> ‚Äî combine publisher you can subscribe to

@Binding

@Binding var name: String

	‚Ä¢	wrappedValue is the actual name
	‚Ä¢	$name returns itself ‚Äî because a Binding is its own projection

‚∏ª

üß™ You Can Build Your Own

Here‚Äôs a minimal custom wrapper:

@propertyWrapper
struct Tracked<T> {
    var wrappedValue: T

    var projectedValue: String {
        return "You accessed this!"
    }
}

struct Example {
    @Tracked var foo = 42

    func test() {
        print(foo)      // ‚Üí 42
        print($foo)     // ‚Üí "You accessed this!"
    }
}

‚úÖ Summary

Name
Meaning
wrappedValue
The actual value you‚Äôre storing
projectedValue
The $something ‚Äî extra capability
@State var x
Defines _x: State<Int> with wrapped/projected
$x
Shorthand for _x.projectedValue


This system is deeply powerful ‚Äî it allows for transparent wrappers that behave like variables but have hooks and behaviors (just like C macros or inline functions, but safe and composable).


==================================================================

Handbook Entry: property-wrappers.txt
======================================

Overview
--------
A **property wrapper** in Swift is a way to add logic or behavior around
a stored property, such as validation, observation, or computed access.
SwiftUI uses them extensively (e.g., @State, @Binding, @Published).

Two key internal names power this feature:

‚Ä¢ wrappedValue     ‚Äî The "real" value being stored and exposed.
‚Ä¢ projectedValue   ‚Äî An optional "extra" value, available via $prefix syntax.

These names are NOT magic ‚Äî they are real, inspectable, and customizable.


Basic Mechanics
---------------
Defining a property wrapper looks like this:

    @propertyWrapper
    struct MyWrapper {
        var wrappedValue: String
    }

    struct Example {
        @MyWrapper var name: String
    }

The Swift compiler expands this to something like:

    var _name = MyWrapper(wrappedValue: "")
    var name: String {
        get { _name.wrappedValue }
        set { _name.wrappedValue = newValue }
    }


wrappedValue
------------
Every property wrapper must define this. It provides access to the actual value.
In SwiftUI, when you read or write the property, you're actually accessing `wrappedValue`.

    @State var count: Int = 0

    // Internally becomes something like:
    var _count = State(initialValue: 0)
    var count: Int {
        get { _count.wrappedValue }
        set { _count.wrappedValue = newValue }
    }


projectedValue
--------------
Optional. If defined, this enables use of the $ prefix:

    var projectedValue: SomeType

Then:

    $myProp  ==  _myProp.projectedValue

Examples:

‚Ä¢ @State ‚Üí $name gives a Binding<String>
‚Ä¢ @Published ‚Üí $name gives a Publisher<String>
‚Ä¢ @Binding ‚Üí $name gives Binding<T> (identity projection)


Example: Custom Property Wrapper
--------------------------------
    @propertyWrapper
    struct Tracked<T> {
        var wrappedValue: T

        var projectedValue: String {
            "You accessed this!"
        }
    }

    struct Example {
        @Tracked var foo = 42

        func test() {
            print(foo)    // 42
            print($foo)   // "You accessed this!"
        }
    }


SwiftUI Examples
----------------

1. @State
    @State var name: String
    ‚Ä¢ wrappedValue = name
    ‚Ä¢ projectedValue = Binding<String> (used for $name)

2. @Binding
    @Binding var name: String
    ‚Ä¢ wrappedValue = actual value from parent
    ‚Ä¢ projectedValue = itself (Binding<T>)

3. @Published
    class ViewModel: ObservableObject {
        @Published var name: String
    }
    ‚Ä¢ wrappedValue = name
    ‚Ä¢ projectedValue = Combine Publisher<String>


Summary
-------
| Concept          | Meaning                                        |
|------------------|------------------------------------------------|
| wrappedValue     | The underlying value                           |
| projectedValue   | Optional. Enables use of $ to access extra API |
| $x               | Equivalent to _x.projectedValue                |
| Used by SwiftUI  | @State, @Published, @Binding, etc.             |

This system provides clean abstraction while preserving access to internals.
Think of it as a Swifty equivalent of C-level getter/setter macros ‚Äî but safe.
