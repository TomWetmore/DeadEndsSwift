Property wrappers are one of the elegant inventions in Swift‚Äôs history, and they came relatively late in the language‚Äôs evolution. 

Pre‚ÄìProperty Wrappers Era -- Swift 1‚Äì4 (2014‚Äì2018) had attributes like @objc and computed properties, but no general way to abstract repeated boilerplate around property access. Frameworks like Core Data and UserDefaults often had to resort to ugly macros or custom accessors.In SwiftUI‚Äôs early design, Apple needed a way to automatically hook into property storage (like @State, @Binding, @ObservedObject). That need drove the feature.

Introduction (Swift 5.1, 2019) --WWDC 2019: Apple unveiled SwiftUI, and and introduced property wrappers as the enabling language feature. The syntax was immediately recognizable: @State var count = 0.Under the hood: @State was just a struct conforming to @propertyWrapper protocol with a wrappedValue and (optionally) projectedValue.	This was the first public proof of the power property wrappers gave, turning repetitive boilerplate into a declarative annotation.

Evolution -- Swift 5.1 (2019) -- You could define your own wrappers like @UserDefault. Swift 5.2 (2020) - wrappers gained more expressive initialization options (init(wrappedValue:)), which made them easier to use.	Swift 5.4/5.5 (2021) - improvements around local variables and concurrency interactions. Swift 5.7+ (2022‚Äì2023) : more refinements, especially around @MainActor and distributed actors, which clarified how wrappers behave in concurrent contexts.

Real-world impact.  Property wrappers became the backbone of SwiftUI:
‚Ä¢ @State, @Binding, @ObservedObject, @EnvironmentObject, @Published ‚Ä¶ all are wrappers.
‚Ä¢ They spread beyond UI:
‚Ä¢ Persistence (@UserDefault, @AppStorage)
‚Ä¢ Synchronization (@Atomic)
‚Ä¢ Validation (@Clamped(min:max:))
‚Ä¢ Dependency injection (common in Swift server frameworks)

Without wrappers, these things require verbose boilerplate.

Why they matter historically:
‚Ä¢ Before property wrappers, many languages solved similar needs with annotations (Java‚Äôs @Annotation, C#‚Äôs attributes, Rust macros).
‚Ä¢ Swift‚Äôs twist was: wrappers are just types ‚Äî structs/classes you can write yourself. That means you get real code, not compiler magic.
‚Ä¢ This was a big philosophical win: Swift stayed consistent with its type system rather than introducing a second, ‚Äúmagical‚Äù layer.

So in short:
‚Ä¢ Born out of SwiftUI‚Äôs need.
‚Ä¢ Publicly launched with Swift 5.1 in 2019.
‚Ä¢ Rapidly became a core idiom of modern Swift.
‚Ä¢ They represent Apple‚Äôs broader trend: take ‚Äúpatterns‚Äù that people repeat, and bake them into the language as lightweight constructs.
------------------------------
The famous @State counter demo

struct CounterView: View {
    @State private var count = 0
    var body: some View {
        VStack {
            Text("Count: \(count)")
            Button("Increment") {
                count += 1
            }
        }
    }
}

Looks magical. You declare @State, and the UI updates when count changes.

What this looked like before property wrappers

struct CounterView: View {
    private var _count = State(initialValue: 0) // Need special storage
    var count: Int {
        get { _count.wrappedValue }
        set { _count.wrappedValue = newValue }
    }
    var body: some View {
        VStack {
            Text("Count: \(count)")
            Button("Increment") {
                count += 1
            }
        }
    }
}

Here: _count is the actual storage (State<Int>). count is a computed property that forwards through .wrappedValue. Apple realized: we can automate this pattern with an attribute.

What the compiler really generates.  When you write @State private var count = 0, the compiler expands it almost exactly into the ‚Äúbefore‚Äù version above. In fact, the synthesized code is:

private var _count = State<Int>(initialValue: 0)
var count: Int {
    get { _count.wrappedValue }
    set { _count.wrappedValue = newValue }
}
And you also get self.$count, which is just _count.projectedValue (the publisher).

At WWDC19 Session 226 ‚ÄúIntroducing SwiftUI‚Äù, they demoed @State live for the first time. That was the debut of property wrappers as a language feature in Swift 5.1 ‚Äî literally created so SwiftUI could exist. From there: @Binding, @ObservedObject, @EnvironmentObject are‚Üí all built the same way. Developers quickly started writing custom wrappers (@UserDefault, @Clamped, etc.).

So property wrappers aren‚Äôt compiler black magic. They‚Äôre syntactic sugar for a storage pattern that every SwiftUI property would otherwise have to repeat by hand. ‚ú®

Let‚Äôs dig into projectedValue and why $count exists.

Every property wrapper has two important pieces when you create it.

@propertyWrapper
struct Example<Value> {
    var wrappedValue: Value
    var projectedValue: SomeOtherType { ... }
}

‚Ä¢ wrappedValue is what  you access normally (count).
‚Ä¢ projectedValue is what you access with the $ prefix ($count).

That is count is _count.wrappedValue and $count is _count.projectedValue
That $ syntax is not special to SwiftUI ‚Äî it‚Äôs part of the property wrapper design.

In @State

State<Value> looks (simplified) like:

@propertyWrapper
public struct State<Value>: DynamicProperty {
    public var wrappedValue: Value
    public var projectedValue: Binding<Value> {
        Binding(
            get: { self.wrappedValue },
            set: { self.wrappedValue = $0 }
        )
    }
}

‚Ä¢ So count is just wrappedValue (the Int).
‚Ä¢ $count is the Binding<Int> that SwiftUI can pass into subviews.

When you write: 'TextField("Enter name", text: $name)',e name is a String, but $name is a Binding<String> that tells the TextField how to read and write to the same storage.

Similarly, '@Published var foo' gives you:
‚Ä¢ foo ‚Üí the value itself.
‚Ä¢ $foo ‚Üí a Publisher (Published<Value>.Publisher) that emits whenever foo changes.

That‚Äôs why you can say:

vm.$foo.sink { newValue in ... }


When I said:

self.$count is just _count.projectedValue

That means: the compiler generates a hidden _count: State<Int> field, and accessing $count simply forwards to _count.projectedValue, which is a Binding<Int>.

So in code, you could think of:

$count === _count.projectedValue
count  === _count.wrappedValue

@propertyWrapper is new Swift syntax that was introduced in Swift 5.1 (2019) alongside SwiftUI.  Apple needed a general mechanism to make things like @State possible, so they added property wrappers as a language feature.

How it works.  Declaring a wrapper is just writing a struct (or class) with the @propertyWrapper attribute:

@propertyWrapper
struct Clamped {
    private var value: Int
    private let range: ClosedRange<Int>
    
    init(wrappedValue: Int, _ range: ClosedRange<Int>) {
        self.range = range
        self.value = range.clamp(wrappedValue)
    }
    
    var wrappedValue: Int {
        get { value }
        set { value = range.clamp(newValue) }
    }
}

Now you can use it as new syntax on a property:

struct Example {
    @Clamped(0...10) var score: Int = 5
}

var e = Example()
e.score = 15
print(e.score)   // prints 10 (clamped)

The compiler automatically:
	‚Ä¢	Creates a hidden _score: Clamped behind the scenes.
	‚Ä¢	Makes score forward into _score.wrappedValue.

‚∏ª

Why new syntax?

Because Apple wanted:
	‚Ä¢	The declarative style: @State var count = 0 is a lot clearer than ‚Äúmake a wrapper type and forward into .wrappedValue‚Äù.
	‚Ä¢	The ability to extend Swift beyond SwiftUI. @UserDefault, @Atomic, @Clamped, @Regex‚Ä¶ these all come from the same mechanism.

So yes: @propertyWrapper is brand-new syntax, but it‚Äôs really just compiler sugar over a pattern Swift could already express.

‚∏ª

Fun fact üéâ

In Swift Evolution, property wrappers were originally proposed under the name ‚Äúproperty delegates‚Äù. They renamed them before Swift 5.1 landed, but you still sometimes see delegateValue or delegated in very old drafts.

‚∏ª

Want me to show you the compiler desugaring of a simple wrapper (what your code expands into under the hood), so you can see why they needed the new @propertyWrapper keyword?

I;ll be turning this discussion into another handbook chapter.

That sounds fantastic üìò‚ú® ‚Äî this little journey from @Published plumbing to the history of @propertyWrapper really does read like a coherent chapter. You‚Äôve got:
	1.	The motivation ‚Äî why SwiftUI needed something like property wrappers.
	2.	The syntax ‚Äî @propertyWrapper as the new language feature.
	3.	How it works under the hood ‚Äî hidden _foo, wrappedValue, projectedValue.
	4.	Historical context ‚Äî Swift 5.1, WWDC 2019, originally called property delegates.
	5.	Practical demos ‚Äî @State, @Published, and a custom wrapper like @Clamped.

That‚Äôs a perfect arc: it goes from ‚Äúmystical‚Äù to ‚Äúmechanical.‚Äù

If you want, I can help you shape an outline for the chapter so that it flows as both a technical reference and a narrative of discovery. Would you like me to sketch that out?
