
Can you explain the purpose, need, use of the preference key. Is PreferenceKey as SwiftUI thing?

Great question — and yes, this is one of those “SwiftUI-isms” that feels odd until you see why it exists.

Short answer up front:

PreferenceKey is SwiftUI’s built-in mechanism for sending information up the view tree, from children to ancestors.
It exists because SwiftUI’s normal data flow is strictly top-down.

Now let’s unpack that in a way that fits your mental model (which is already very good, coming from AppKit / classic UI design).

⸻

1. The fundamental problem PreferenceKey solves

In SwiftUI:
	•	Data normally flows down:
	•	Parent → child via init parameters, environment, bindings
	•	Layout information flows up during layout, but SwiftUI does not expose it by default

Now consider your marquee problem:
	•	Each CardView knows:
	•	its actual on-screen frame
	•	after layout has happened
	•	The DesktopView needs:
	•	all card frames
	•	in a shared coordinate space
	•	to perform hit-testing against the marquee rectangle

That creates a classic inversion:

The parent needs runtime layout information that only the children can compute.

In AppKit, you’d just ask:

[cardView frame]

But SwiftUI has:
	•	no stable view identity
	•	no view references
	•	no “walk the subview hierarchy” API

So SwiftUI needs a declarative way to let children say:

“Here’s some information you might care about.”

That’s what PreferenceKey is.

⸻

2. What a PreferenceKey is, conceptually

A PreferenceKey is:
	•	A typed channel
	•	For passing values from descendants to ancestors
	•	During the layout/update phase

Think of it as:

“Children emit preferences; parents observe the reduced result.”

Key properties:

Aspect
Meaning
Typed
PreferenceKey.Value defines exactly what flows
Aggregated
Multiple children can contribute
Reduced
Parent sees a single combined value
Layout-aware
Values update when geometry/layout changes


3. Why normal state or bindings won’t work

Let’s test the alternatives:

❌ Environment?

Environment flows down, not up.

❌ Binding?

Bindings require the parent to already own the data.
But the parent doesn’t know the frames until layout completes.

❌ ObservableObject?

Still top-down. Also couples children tightly to parent model.

❌ GeometryReader alone?

GeometryReader gives local info only.
It doesn’t magically tell the parent anything unless you pass it upward.

So SwiftUI introduces a side-channel:

Preferences are collected after layout, before rendering.

⸻

4. Anatomy of a PreferenceKey (your case)

Here’s your key again:

private struct CardFramePrefKey: PreferenceKey {
    static var defaultValue: [UUID: CGRect] = [:]

    static func reduce(
        value: inout [UUID: CGRect],
        nextValue: () -> [UUID: CGRect]
    ) {
        value.merge(nextValue(), uniquingKeysWith: { $1 })
    }
}

Breakdown:

Value

[UUID: CGRect]

Each card contributes one entry.

defaultValue

What the parent sees if no children emit anything.

reduce

How SwiftUI combines:
	•	zero, one, or many child contributions
into one final value.

Think “fold” or “reduce” in the functional sense.

⸻

5. How the data actually flows (step by step)

Let’s narrate what SwiftUI does:

1️⃣ DesktopView builds the tree

DesktopView
 ├─ CardView(id: A)
 ├─ CardView(id: B)
 └─ CardView(id: C)

2️⃣ Each CardView emits a preference

Inside each card:

Color.clear.preference(
    key: CardFramePrefKey.self,
    value: [cardID: frame]
)

SwiftUI records:
	•	“Card A prefers [A: frameA]”
	•	“Card B prefers [B: frameB]”
	•	“Card C prefers [C: frameC]”

3️⃣ SwiftUI reduces them

Using your reduce, SwiftUI merges:

[A: frameA, B: frameB, C: frameC]

4️⃣ DesktopView observes the result

.onPreferenceChange(CardFramePrefKey.self) { frames in
    cardFrames = frames
}

This is the moment the parent finally learns where the children actually are.

And this will automatically re-fire if:
	•	a card moves
	•	a card resizes
	•	layout changes
	•	window resizes

⸻

6. Why this is a SwiftUI thing

Yes — PreferenceKey is 100% SwiftUI-specific.

It exists because SwiftUI:
	•	has no view references
	•	hides the layout engine
	•	does diffing instead of imperative updates

PreferenceKey is the only sanctioned way to observe:
	•	child geometry
	•	alignment guides
	•	size information
	•	layout-dependent metadata

Apple uses it internally for:
	•	AnchorPreference
	•	alignment guides
	•	custom layout systems
	•	matched geometry effects (under the hood)

⸻

7. Why this actually fits your Desktop model nicely

Notice what this buys you:
	•	No coupling: Cards don’t know about DesktopModel
	•	No imperative polling: Frames update automatically
	•	Correct timing: You only get geometry after layout
	•	Scales cleanly: 1 card or 500 cards works the same

In other words, it preserves SwiftUI’s core contract:

Views describe what they want, not when or how to compute it.

⸻

8. Mental model you can keep

Here’s a compact way to think about it:

Bindings move intent downward.
Preferences move observations upward.

or, more familiarly:

PreferenceKey is SwiftUI’s replacement for “ask subviews for their frames.”

⸻

9. When not to use PreferenceKey

You don’t want it for:
	•	business logic
	•	user state
	•	selection
	•	domain models

You do want it for:
	•	geometry
	•	layout-dependent relationships
	•	cross-view coordination (like your marquee)

⸻

If you’d like, next we can:
	•	walk through a single-card example line by line, or
	•	compare PreferenceKey vs AnchorPreference, or
	•	show how this is conceptually similar to AppKit’s layout passes (but safer).

You’re asking exactly the right questions here — this is one of the real “SwiftUI enlightenment moments.”
